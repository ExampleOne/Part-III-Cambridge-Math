\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{float}
\usepackage{gensymb}
\usepackage{amsthm}
\usepackage{longtable}
\usepackage{adjustbox}
\usepackage{physics}

\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}

\title{Quantum Computation}
\author{quinten tupker}
\date{October 8 2020 - \today}

\begin{document}

\maketitle

\section*{Introduction}

These notes are based on the course lectured by Professor Richard Jozsca in
Michaelmas 2020. Due to the measures taken in the UK to limit the spread of
Covid-19, these lectures were delivered online. These are not meant to be an
accurate representation of what was lectures. They solely represent a mix of
what I thought was the most important part of the course, mixed in with many
(many) personal remarks, comments and digressions... Of course, any
corrections/comments are appreciated.

This course is meant to be a second course on quantum computation. In
particular, all the prerequisite knowledge is covered in Cambridge's Part II
Quantum Information and Computation course. Lecture notes for this course can be
found online.

Now, to start describing course content. Quantum Computation studies algorithms
that can be run on quantum computers. Although they have yet to be implemented
in practice (but are definitely being developed at a rapid pace), and in
particular how they differ with classical computation. A remarkable result, is
that at least superficially, quantum algorithms appear to be more powerful than
classical algorithms, although it remains unclear if this is definite fact, or
if it simply easier for humans to solve complex problems using quantum
algorithms instead of classical algorithms. This is remarkable in many ways in a
philosophical sense, but here we focus on how to take advantage of these
changes. As such, we will begin with a review and extension of one of the most
famous quantum algorithms, which is Schur's factoring algorithm.

\section{Schur's Algorithm Revisited and the Hidden Hidden Subgroup Problem}

Schur's factoring algorithm finds a factor for an arbitrary number $N$. It does
not perform a complete factorisation. It merely computes a factor, which of
course can be repeated arbitrarily to get a complete factorisation, but that is
not the point here. The complexity of such an algorithm is typically measured in
terms of the number of digits of $N$, which we may denote $n = \ln(N)$. In these
terms Schur's algorithm is $O(n^3)$, which means it is ``efficient''
(computationally feasible) or

\begin{definition}[efficient algorithm]
  An algorithm is efficient if it runs in polynomial time, which generally means
  it is considered doable in practice.
\end{definition}

By comparison, the fastest known classical algorithm runs in
$O(e^{n^{1/3}\ln(n)^{1/3}})$.

Anyways, here is an outline of Schur's algorithm:

\begin{enumerate}
\item choose $a < N$ such that $(a, N) = 1$ (coprime). This can be done
  efficiently, since the probability of $a$ being coprime is fixed, and we can
  quickly calculate the GCD using Euclid's algorithm. Then consider $f(x) =
  a^x (\text{mod} N)$.
\item Use quantum algorithms to calculate the period of the this function
  (so we have converted a factoring problem into period finding). Since $a$
  is coprime, it is guaranteed to be periodic.
\item compute the factor using number theory
\end{enumerate}

The crucial component here is the period finding, which cannot be done
efficiently using a classical algorithm. So let's review quantum period finding.
Also, note that as usual, quantum oracles are implemented as unitary operators
by converting $f : \mathbb{Z}_M \to \mathbb{Z}_N$ to $U_f \ket{x} \ket{0}
\mapsto \ket{x} \ket{f(x)}$. Then, if $f$ has period $r$ (unknown), and $f$ is
one-to-one on every period, then period finding can be done using

\begin{enumerate}
\item make $\frac{1}{\sqrt{M}} \sum_0^{M - 1} \ket{i}\ket{0}$
\item apply $U_f$
\item measure the output register to get
  $$ \frac{1}{\sqrt{A}} (\ket{x_0} + \ket{x_0 + r} + \dots + \ket{x_0 + (A -
    1)r}) \ket{f(x_0)} $$
  Now the next step is the tricky part, and really is what uses the ``quantum
  magic'' here, and that involves the use of the Quantum Fourier Transform
  (QFT). [This ends lecture 1]
\item We then apply the QFT, which maps $\ket{k} \mapsto \sum_{y = 0}^M e^{xy}
  \ket{y}$, which, after some calculation (use $\sum e^{2\pi kx/y} =
  y\delta_{xy}$) leaves us with
$$ \text{QFT} \ket{\text{per}} = \sqrt{A / M} \sum_{k = 0}^{r - 1} \omega^{x_0 k
M/r} \ket{k M / r} $$
\item Making a measurement we get $C = k_0 M / r$, so $\frac{k_0}{r} =
  \frac{C}{M}$. If $k_0, r$ are coprime, we are done, since we can reduce
  $\frac{C}{M}$ to simplest terms (use Euclid's algorithm to cancel out the
  gcd). Now, number theory tells us that the probability of being coprime is
  finite and shrinks slowly (as $O(1 / \log \log (M))$), and so we can just
  repeat until we get the right period. Since $f$ is one-to-one on each period,
  it is easy to check if our period is correct.
\end{enumerate}

I feel that just being able to check if the period is correct is a somewhat lame
reason to require that the function be one-to-one on each period, but
improvements although not difficult, would complicate this explanation.

Anyways, let's see if we can motivate the Quantum Fourier Transform a bit
better. The challenge we face is that our state, $\ket{R}$ takes the form

$$ \ket{R} = \sum_k a_k \ket{x_0 + kr} $$

for an arbitrary $x_0$. In other words, we have an arbitrary shift that we want
to ignore some how. How do we do that? A natural way to spot ``things that
ignore shifts'' would be to define the shhift operator

$$ U \ket{x} = \ket{x + 1 \text{ mod } M} $$

and then, how do we say, ``we don't care about '' $U$? We look for the
eigenvectors of $U$, which are by definition, the states least affected by $U$.
Fortunately, $U$ is a permuatation matrix, so unitary, so is a quantum gate.
Then, the eigenbasis of $U$ is what we may call the set of shift-invariant
states $\chi_k$. If we write $R$ in terms of this basis we are bound to get a
state of the form

$$ \sum_k a_k \lambda_k^{x_0} \ket{\chi_k} $$

where $\mathbb{P}(k) = |a_k \lambda_k^{x_0}|^2 = |a_k|^2$ since as eigenvalues
of a unitary matrix, $|\lambda_k| = 1$ always. So as expected, probabilities are
preserved (this is not that crucial - but it's important they don't differ that
much). Anyways, important is that this transformation allows us to express our
state as a sum of multiples of the period, which is what we want.

All that remains is to find this basis, and the operation that expresses them in
terms of it. As eigenvectors of a unitary matrix are orthogonal, all we need to
do is zip the eigenvectors into a matrix. These eigenvectors are just of the
form $e^{2\pi i k l/ M}$, so we get the Quantum Fourier Transform we expect.
[End of lecture 2]

\subsection{The Hidden Subgroup Problem (HSP)}

The hidden subgroup problem asks
the question how can we find subgroup $K$ of group $G$ (this course only
considers finite $G$) given a function $f : G \to X$ that is an invertible
function of the left cosets of $K$. Our goal is to solve this problem in
$O(poly(\ln(|G|)))$.

Examples of this include Schur's algorithm where we have $G = \mathbb{Z}_p^*$,
then $K = {0, r, 2r, \dots}$, and then $f$ used before works for our purpose.
Another example is calculating \textbf{discrete logarithm}, which if done
efficiently could break encryption methods. This involves calculating logarithms
on $\mathbb{Z}_p^*$, so given $x$ finding $y$ such that for group generator $g$,
$x = g^y$. To formulate this as an HSP consider

\begin{align*}
  f : \mathbb{Z}_{p - 1} \times \mathbb{Z}_{p - 1} &\to \mathbb{Z}_p^* \\
  (a, b) &\mapsto g^ax^{-b} = g^{a - yb}
\end{align*}

where we can see that $f(a_1, b_1) = f(a_2, b_2)$ iff $(a_2. b_2) - (a_1, b_1) =
\lambda (y, 1)$ some $\lambda$. So using $K = \{\lambda (y, 1) | \lambda \in
\mathbb{Z}_{p - 1}\}$ works.

Those both involve abelian groups, but a big area of interest is solving
the problem for non-abelian groups. Examples of such problems include finding
the Automorphism group of a graph. For graph $A$ this means finding
$\text{Aut}(A)$ a subgroup of the group of permutations of the vertices of $A$
such that the overall structure (edges) are preserved. This can be formulated
quite naturally into an HSP by taking $X$ to be the set of all $n$ vertex
graphs, and then to consider the function $f_A(\pi)$ which applies permutation
$\pi$ to $A$. Clearly the result depends only on the coset of $\text{Aut}(A)$.

Even more famous is the \textbf{Graph Isomorphism} problem (GI), which is to
check whether or not two labelled graphs are isomorphic (so whether there exists
a permutation turning one into the other). This can be converted into an HSP,
although the process is more complicated. There also exists few good classical
algorithms, although in 2017 someone found an algorithm doing it in
quasi-polynomial time. 

But how far will we get with quantum algorithms. The abelian case has been fully
solved, but unfortunately the non-abelian case (which the above two problems
belong to) remains an important unsolved problem in the field. [End of lecture 3]

Briefly, another example of an HSP involving the Dihedral group is how to
calculate the shortest vector within a lattice. No good quantum algorithm exists
to solve this problem.

Now, let's develop the formalism to describe the quantum algorithm to solve the
hidden subgroup problem for any finite abelian group. Contrary to my
expectations, we jump straight into representation theory. Well, that is not
really contrary to my expectations, but I had imagine it would be more natural
to look at the problem as permutations, and to define invariant states from
there. Apparently, while it is not mentioned, it does not seem to be the central
approach thought of here.

Instead we rely on the fact that for a finite abelian group, all representations
can be seen as one dimensional representations $\chi : G \to S^1$, the unit
circle embedded in the complex plain. Being one dimensional they are all
irreducible, and also satisfy the following three properties:

\begin{itemize}
\item $\chi(g) = e^{2\pi i k / |G|}$ some $k \in \mathbb{Z}$
\item $\langle \chi_i, \chi_j \rangle = \frac{1}{|G|} \sum_{g \in G} \chi_i(g)
  \chi_j^*(g) = \delta_{ij}$
\item There are exactly $|G|$ distinct such representations, which we may label
  $\chi_g$
\item the restriction of an irreducible representation to a subgroup is also
  irreducible
\end{itemize}

A particular application of this is that \textbf{trivial representation}
$\chi_0(g) = 1$ is orthogonal to all other representations, so in general
$\sum_g \chi_k(g) = 0$. This will be helpful later on. Also, note that since
this is an abelian group, we will use $+$ to denote the group operation.

Now the crucial advantage that the abelian case has over the non-abelian case is
that all elements commute, meaning in particular that all representations can be
simultaneously diagonalised, which means a universal shift invariant state
exists. In particular, we notice that

$$ \ket{\chi_k} = \frac{1}{\sqrt{|G|}} \sum_{g \ in G} \overline{\chi_k(g)}
\ket{g} $$

Here the complex conjugate is really just convention, but it makes things look
similar to Schur's algorithm. Here it is easy to see that the eigenvalues of a
shift by $g$, denoted $U(g)$ is $U_k(g) \ket{\chi_k} = \chi_k(g) \ket{\chi_k}$.

The Quantum Fourier Transform (QFT) then as expected swaps the standard unit
basis with the shift invariant basis meaning that $QFT \ket{\chi_g} = \ket{g}$
so considering components approrpiately, and transposing to get the inverse we
find

$$ QFT \ket{g} = \frac{1}{\sqrt{|G|}} \sum_{k \in G} \chi_k(g) \ket{k} $$

Now, since we can classify all finite abelian groups as the product of cyclic
groups, the following result on representations of such groups is quite valuable

\begin{example}
For $G = \mathbb{Z}_M$, $\chi_a(b) = e^{2 \pi i ab / M}$ describes all
representations of $G$. Even better is that for $G = \mathbb{Z}_{m_1} \times
\dots \times \mathbb{Z}_{M_r}$, $\chi_{a}(b) = e^{2\pi i (a_1b_1 / M_1 + \dots +
  a_r b_r / M_r)}$. Furthermore, in this case

$$ QFT_G = QFT_{M_1} \otimes \dots \otimes QFT_{M_r} $$
\end{example}

Now let's start to truly describe the HSP algorithm for finite abelian groups.
Here we are given oracle $f:G \to K$ and we work on state space
$\mathcal{H}_{|G|} \otimes \mathcal{H}_{|K|}$

\begin{enumerate}
\item form the state space $ \frac{1}{\sqrt{|G|}} \sum_{g \in G} \ket{g}\ket{0}$
\item Apply $U_f$ for form $\frac{1}{\sqrt{|G|}} \sum_{g \ in G} \ket{g} \ket{f(g)}$
\item measure second register to get $\ket{g_0 + K}$ where $\ket{K} =
  \frac{1}{\sqrt{|K|}} \sum_{k \in K} \ket{k}$. 
\item Apply QFT and measure to get some state $\chi_g$. Note that here $g$
  does not depend on $g_0$ due to the QFT, which is the strength of this
  algorithm. [End of lecture 4]
\end{enumerate}


\end{document}